{
  "questionId": "2111",
  "questionFrontendId": "1966",
  "title": "Binary Searchable Numbers in an Unsorted Array",
  "titleSlug": "binary-searchable-numbers-in-an-unsorted-array",
  "content": "<p>Consider a function that implements an algorithm <strong>similar</strong> to <a href=\"https://leetcode.com/explore/learn/card/binary-search/\" target=\"_blank\">Binary Search</a>. The function has two input parameters: <code>sequence</code> is a sequence of integers, and <code>target</code> is an integer value. The purpose of the function is to find if the <code>target</code> exists in the <code>sequence</code>.</p>\n\n<p>The pseudocode of the function is as follows:</p>\n\n<pre>\nfunc(sequence, target)\n  while sequence is not empty\n    <strong>randomly</strong> choose an element from sequence as the pivot\n    if pivot = target, return <strong>true</strong>\n    else if pivot &lt; target, remove pivot and all elements to its left from the sequence\n    else, remove pivot and all elements to its right from the sequence\n  end while\n  return <strong>false</strong>\n</pre>\n\n<p>When the <code>sequence</code> is sorted, the function works correctly for <strong>all</strong> values. When the <code>sequence</code> is not sorted, the function does not work for all values, but may still work for <strong>some</strong> values.</p>\n\n<p>Given an integer array <code>nums</code>, representing the <code>sequence</code>, that contains <strong>unique</strong> numbers and <strong>may or may not be sorted</strong>, return <em>the number of values that are <strong>guaranteed</strong> to be found using the function, for <strong>every possible</strong> pivot selection</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7]\n<strong>Output:</strong> 1\n<strong>Explanation</strong>: \nSearching for value 7 is guaranteed to be found.\nSince the sequence has only one element, 7 will be chosen as the pivot. Because the pivot equals the target, the function will return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,5,2]\n<strong>Output:</strong> 1\n<strong>Explanation</strong>: \nSearching for value -1 is guaranteed to be found.\nIf -1 was chosen as the pivot, the function would return true.\nIf 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only -1 and the function would return true.\nIf 2 was chosen as the pivot, 2 would be removed. In the next loop, the sequence would have -1 and 5. No matter which number was chosen as the next pivot, the function would find -1 and return true.\n\nSearching for value 5 is NOT guaranteed to be found.\nIf 2 was chosen as the pivot, -1, 5 and 2 would be removed. The sequence would be empty and the function would return false.\n\nSearching for value 2 is NOT guaranteed to be found.\nIf 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only -1 and the function would return false.\n\nBecause only -1 is guaranteed to be found, you should return 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> If <code>nums</code> has <strong>duplicates</strong>, would you modify your algorithm? If so, how?</p>\n",
  "difficulty": "Medium",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int binarySearchableNumbers(vector<int>& nums) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int binarySearchableNumbers(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def binarySearchableNumbers(self, nums: List[int]) -> int:\n        "
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def binarySearchableNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar binarySearchableNumbers = function(nums) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "code": "function binarySearchableNumbers(nums: number[]): number {\n    \n};"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int BinarySearchableNumbers(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "code": "int binarySearchableNumbers(int* nums, int numsSize) {\n    \n}"
    },
    {
      "lang": "Go",
      "code": "func binarySearchableNumbers(nums []int) int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun binarySearchableNumbers(nums: IntArray): Int {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func binarySearchableNumbers(_ nums: [Int]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn binary_searchable_numbers(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef binary_searchable_numbers(nums)\n    \nend"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function binarySearchableNumbers($nums) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "code": "class Solution {\n  int binarySearchableNumbers(List<int> nums) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def binarySearchableNumbers(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "code": "defmodule Solution do\n  @spec binary_searchable_numbers(nums :: [integer]) :: integer\n  def binary_searchable_numbers(nums) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "code": "-spec binary_searchable_numbers(Nums :: [integer()]) -> integer().\nbinary_searchable_numbers(Nums) ->\n  ."
    },
    {
      "lang": "Racket",
      "code": "(define/contract (binary-searchable-numbers nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"
    }
  ],
  "stats": "{\"totalAccepted\": \"3.7K\", \"totalSubmission\": \"5.8K\", \"totalAcceptedRaw\": 3704, \"totalSubmissionRaw\": 5850, \"acRate\": \"63.3%\"}",
  "metaData": "{\n  \"name\": \"binarySearchableNumbers\",\n  \"params\": [\n    {\n      \"name\": \"nums\",\n      \"type\": \"integer[]\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}",
  "sampleTestCase": "[7]"
}