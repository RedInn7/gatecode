{
  "questionId": "281",
  "questionFrontendId": "281",
  "title": "Zigzag Iterator",
  "titleSlug": "zigzag-iterator",
  "content": "<p>Given two vectors of integers <code>v1</code> and <code>v2</code>, implement an iterator to return their elements alternately.</p>\n\n<p>Implement the <code>ZigzagIterator</code> class:</p>\n\n<ul>\n\t<li><code>ZigzagIterator(List&lt;int&gt; v1, List&lt;int&gt; v2)</code> initializes the object with the two vectors <code>v1</code> and <code>v2</code>.</li>\n\t<li><code>boolean hasNext()</code> returns <code>true</code> if the iterator still has elements, and <code>false</code> otherwise.</li>\n\t<li><code>int next()</code> returns the current element of the iterator and moves the iterator to the next element.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> v1 = [1,2], v2 = [3,4,5,6]\n<strong>Output:</strong> [1,3,2,4,5,6]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,3,2,4,5,6].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> v1 = [1], v2 = []\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> v1 = [], v2 = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= v1.length, v2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= v1.length + v2.length &lt;= 2000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= v1[i], v2[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if you are given <code>k</code> vectors? How well can your code be extended to such cases?</p>\n\n<p><strong>Clarification for the follow-up question:</strong></p>\n\n<p>The &quot;Zigzag&quot; order is not clearly defined and is ambiguous for <code>k &gt; 2</code> cases. If &quot;Zigzag&quot; does not look right to you, replace &quot;Zigzag&quot; with &quot;Cyclic&quot;.</p>\n\n<p><strong>Follow-up Example:</strong></p>\n\n<pre>\n<strong>Input:</strong> v1 = [1,2,3], v2 = [4,5,6,7], v3 = [8,9]\n<strong>Output:</strong> [1,4,8,2,5,9,3,6,7]\n</pre>\n",
  "difficulty": "Medium",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class ZigzagIterator {\npublic:\n    ZigzagIterator(vector<int>& v1, vector<int>& v2) {\n        \n    }\n\n    int next() {\n        \n    }\n\n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i(v1, v2);\n * while (i.hasNext()) cout << i.next();\n */"
    },
    {
      "lang": "Java",
      "code": "public class ZigzagIterator {\n\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        \n    }\n\n    public int next() {\n        \n    }\n\n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.hasNext()) v[f()] = i.next();\n */"
    },
    {
      "lang": "Python3",
      "code": "class ZigzagIterator:\n    def __init__(self, v1: List[int], v2: List[int]):\n        \n\n    def next(self) -> int:\n        \n\n    def hasNext(self) -> bool:\n        \n\n# Your ZigzagIterator object will be instantiated and called as such:\n# i, v = ZigzagIterator(v1, v2), []\n# while i.hasNext(): v.append(i.next())"
    },
    {
      "lang": "Python",
      "code": "class ZigzagIterator(object):\n\n    def __init__(self, v1, v2):\n        \"\"\"\n        Initialize your data structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n# Your ZigzagIterator object will be instantiated and called as such:\n# i, v = ZigzagIterator(v1, v2), []\n# while i.hasNext(): v.append(i.next())"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @constructor\n * @param {Integer[]} v1\n * @param {Integer[]} v1\n */\nvar ZigzagIterator = function ZigzagIterator(v1, v2) {\n    \n};\n\n\n/**\n * @this ZigzagIterator\n * @returns {boolean}\n */\nZigzagIterator.prototype.hasNext = function hasNext() {\n    \n};\n\n/**\n * @this ZigzagIterator\n * @returns {integer}\n */\nZigzagIterator.prototype.next = function next() {\n    \n};\n\n/**\n * Your ZigzagIterator will be called like this:\n * var i = new ZigzagIterator(v1, v2), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/"
    },
    {
      "lang": "TypeScript",
      "code": "class ZigzagIterator {\n    constructor(v1: number[], v2: number[]) {\n\t\t\n    }\n\n    next(): number {\n\t\t\n    }\n\n    hasNext(): boolean {\n\t\t\n    }\n}\n\n/**\n * Your ZigzagIterator will be instantiated and called as such:\n * var i = new ZigzagIterator(v1, v2), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/"
    },
    {
      "lang": "C#",
      "code": "public class ZigzagIterator {\n\n    public ZigzagIterator(IList<int> v1, IList<int> v2) {\n        \n    }\n\n    public bool HasNext() {\n        \n    }\n\n    public int Next() {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator will be called like this:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.HasNext()) v[f()] = i.Next();\n */"
    },
    {
      "lang": "C",
      "code": "struct ZigzagIterator {\n    \n};\n\nstruct ZigzagIterator *zigzagIteratorCreate(int* v1, int v1Size, int* v2, int v2Size) {\n    \n}\n\nbool zigzagIteratorHasNext(struct ZigzagIterator *iter) {\n    \n}\n\nint zigzagIteratorNext(struct ZigzagIterator *iter) {\n    \n}\n\n/** Deallocates memory previously allocated for the iterator */\nvoid zigzagIteratorFree(struct ZigzagIterator *iter) {\n    \n}\n\n/**\n * Your ZigzagIterator will be called like this:\n * struct ZigzagIterator *i = zigzagIteratorCreate(v1, v1Size, v2, v2Size);\n * while (zigzagIteratorHasNext(i)) printf(\"%d\\n\", zigzagIteratorNext(i));\n * zigzagIteratorFree(i);\n */"
    },
    {
      "lang": "Go",
      "code": "type ZigzagIterator struct {\n    \n}\n\nfunc Constructor(v1, v2 []int) *ZigzagIterator {\n    \n}\n\nfunc (this *ZigzagIterator) next() int {\n    \n}\n\nfunc (this *ZigzagIterator) hasNext() bool {\n\t\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * obj := Constructor(param_1, param_2);\n * for obj.hasNext() {\n *\t ans = append(ans, obj.next())\n * }\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class ZigzagIterator {\n    constructor(v1: IntArray, v2: IntArray) {\n        \n    }\n    \n    fun next(): Int {\n        \n    }\n    \n    fun hasNext(): Boolean {\n        \n    }\n}\n\n// Your ZigzagIterator object will be instantiated and called as such:\n// var i = ZigzagIterator(v1, v2)\n// var ret = ArrayList<Int>()\n// while(i.hasNext()){\n//\t\tret.add(i.next())\n// }"
    },
    {
      "lang": "Swift",
      "code": "class ZigzagIterator {\n    init(_ v1: [Int], _ v2: [Int]) {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n// Your ZigzagIterator object will be instantiated and called as such:\n// var i = ZigzagIterator(v1, v2)\n// var ret = [Int]()\n// while i.hasNext() {\n// \t\tret.append(i.next())\n// }"
    },
    {
      "lang": "Rust",
      "code": "struct ZigzagIterator {\n    \n}\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl ZigzagIterator {\n    /** initialize your data structure here. */\n    \n    fn new(v1: Vec<i32>, v2: Vec<i32>) -> Self {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * let obj = ZigzagIterator::new(v1, v2);\n * let ret_1: i32 = obj.next();\n * let ret_2: bool = obj.has_next();\n */"
    },
    {
      "lang": "Ruby",
      "code": "class ZigzagIterator\n    # @param {Integer[]} v1\n    # @param {Integer[]} v2\n    def initialize(v1, v2)\n        \n    end\n\n    # @return {Boolean}\n    def has_next\n        \n    end\n\n    # @return {Integer}\n    def next\n        \n    end\nend\n\n# Your ZigzagIterator will be called like this:\n# i, v = ZigzagIterator.new(v1, v2), []\n# while i.has_next()\n#    v << i.next\n# end"
    },
    {
      "lang": "PHP",
      "code": "class ZigzagIterator {\n    /**\n     * Initialize your data structure here.\n     * @param Integer[] $v1\n     * @param Integer[] $v2\n     */\n    function __construct($v1, $v2) {\n        \n    }\n    \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n    \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * $obj = ZigzagIterator($v1, $v2);\n * while ($obj->hasNext()) {\n *   array_push($ans, $obj->next())\n * }\n */"
    },
    {
      "lang": "Scala",
      "code": "class ZigzagIterator(_v1: Array[Int], _v2: Array[Int]) {\n    /** initialize your data structure here. */\n    \n    def next(): Int = {\n        \n    }\n    \n    def hasNext(): Boolean = {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * var obj = new ZigzagIterator(v1, v2)\n * while (obj.hasNext()) {\n *     ans += obj.next()\n * }\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"111.1K\", \"totalSubmission\": \"167.2K\", \"totalAcceptedRaw\": 111069, \"totalSubmissionRaw\": 167158, \"acRate\": \"66.4%\"}",
  "metaData": "{\n  \"name\": \"ZigzagIterator\",\n  \"params\": [\n    {\n      \"name\": \"v1\",\n      \"type\": \"list<integer>\"\n    },\n    {\n      \"name\": \"v2\",\n      \"type\": \"list<integer>\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"list<integer>\",\n    \"dealloc\": true\n  },\n  \"manual\": true\n}",
  "sampleTestCase": "[1,2]\n[3,4,5,6]"
}